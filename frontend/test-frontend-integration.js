/**
 * TESTS D'INT√âGRATION FRONTEND-BACKEND
 * =====================================
 * Tests complets de l'application FailDaily c√¥t√© frontend
 * 
 * ‚ö†Ô∏è  PR√âREQUIS: Backend en cours d'ex√©cution sur localhost:3000
 */

import { spawn } from 'child_process';
import fetch from 'node-fetch';

// Configuration des tests
const BACKEND_URL = 'http://localhost:3000/api';
const FRONTEND_URL = 'http://localhost:4200';
const TESTS_CONFIG = {
  timeout: 30000,
  retryAttempts: 3,
  waitTime: 2000
};

// Couleurs pour les logs
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

class FrontendTestSuite {
  constructor() {
    this.results = {
      total: 0,
      passed: 0,
      failed: 0,
      errors: []
    };
  }

  log(message, color = colors.reset) {
    console.log(`${color}${message}${colors.reset}`);
  }

  async delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // ==========================================
  // üîç V√âRIFICATIONS PR√âLIMINAIRES
  // ==========================================

  async checkBackendStatus() {
    this.log('\nüîç V√©rification du backend...', colors.cyan);
    try {
      const response = await fetch(`${BACKEND_URL}/health`, {
        timeout: 5000
      });
      
      if (response.ok) {
        const data = await response.json();
        this.log(`‚úÖ Backend op√©rationnel: ${data.message}`, colors.green);
        return true;
      } else {
        this.log(`‚ùå Backend erreur: ${response.status}`, colors.red);
        return false;
      }
    } catch (error) {
      this.log(`‚ùå Backend inaccessible: ${error.message}`, colors.red);
      return false;
    }
  }

  async checkFrontendStatus() {
    this.log('\nüîç V√©rification du frontend...', colors.cyan);
    try {
      const response = await fetch(FRONTEND_URL, {
        timeout: 5000
      });
      
      if (response.ok) {
        this.log(`‚úÖ Frontend accessible sur ${FRONTEND_URL}`, colors.green);
        return true;
      } else {
        this.log(`‚ùå Frontend erreur: ${response.status}`, colors.red);
        return false;
      }
    } catch (error) {
      this.log(`‚ùå Frontend inaccessible: ${error.message}`, colors.red);
      this.log(`üí° Suggestion: Lancez 'cd frontend && npm start'`, colors.yellow);
      return false;
    }
  }

  // ==========================================
  // üß™ TESTS DE SERVICES ANGULAR
  // ==========================================

  async testAngularEnvironment() {
    this.log('\nüß™ Test: Configuration environnement Angular', colors.blue);
    this.results.total++;

    try {
      // V√©rifier que les fichiers de config existent
      const fs = await import('fs');
      const path = await import('path');
      
      const envPath = path.join(process.cwd(), 'frontend', 'src', 'environments', 'environment.ts');
      const packagePath = path.join(process.cwd(), 'frontend', 'package.json');
      const angularPath = path.join(process.cwd(), 'frontend', 'angular.json');

      if (!fs.existsSync(envPath)) {
        throw new Error('Fichier environment.ts manquant');
      }
      if (!fs.existsSync(packagePath)) {
        throw new Error('Fichier package.json manquant');
      }
      if (!fs.existsSync(angularPath)) {
        throw new Error('Fichier angular.json manquant');
      }

      // V√©rifier la configuration API
      const envContent = fs.readFileSync(envPath, 'utf8');
      if (!envContent.includes('http://localhost:3000/api')) {
        throw new Error('Configuration API incorrecte dans environment.ts');
      }

      this.log(`‚úÖ Configuration Angular valide`, colors.green);
      this.results.passed++;
      return true;

    } catch (error) {
      this.log(`‚ùå Erreur configuration: ${error.message}`, colors.red);
      this.results.failed++;
      this.results.errors.push(`Configuration Angular: ${error.message}`);
      return false;
    }
  }

  async testAPIServices() {
    this.log('\nüß™ Test: Services API Frontend', colors.blue);
    this.results.total++;

    try {
      const fs = await import('fs');
      const path = await import('path');
      
      const servicesPath = path.join(process.cwd(), 'frontend', 'src', 'app', 'services');
      
      // V√©rifier les services critiques
      const criticalServices = [
        'auth.service.ts',
        'mysql.service.ts',
        'fail.service.ts',
        'badge.service.ts'
      ];

      for (const service of criticalServices) {
        const servicePath = path.join(servicesPath, service);
        if (!fs.existsSync(servicePath)) {
          throw new Error(`Service manquant: ${service}`);
        }

        // V√©rifier que le service utilise la bonne URL
        const content = fs.readFileSync(servicePath, 'utf8');
        if (service === 'mysql.service.ts' && !content.includes('environment.api.baseUrl')) {
          throw new Error(`Service ${service} ne r√©f√©rence pas l'environment`);
        }
      }

      this.log(`‚úÖ Services API pr√©sents et configur√©s`, colors.green);
      this.results.passed++;
      return true;

    } catch (error) {
      this.log(`‚ùå Erreur services: ${error.message}`, colors.red);
      this.results.failed++;
      this.results.errors.push(`Services API: ${error.message}`);
      return false;
    }
  }

  // ==========================================
  // üåê TESTS D'INT√âGRATION HTTP
  // ==========================================

  async testCORSConfiguration() {
    this.log('\nüß™ Test: Configuration CORS', colors.blue);
    this.results.total++;

    try {
      // Simuler une requ√™te CORS depuis le frontend
      const response = await fetch(`${BACKEND_URL}/health`, {
        method: 'GET',
        headers: {
          'Origin': FRONTEND_URL,
          'Access-Control-Request-Method': 'GET',
          'Access-Control-Request-Headers': 'Content-Type,Authorization'
        }
      });

      const corsHeaders = response.headers.get('access-control-allow-origin');
      
      if (response.ok && (corsHeaders === '*' || corsHeaders === FRONTEND_URL)) {
        this.log(`‚úÖ CORS configur√© correctement`, colors.green);
        this.results.passed++;
        return true;
      } else {
        throw new Error(`CORS mal configur√©. Headers: ${corsHeaders}`);
      }

    } catch (error) {
      this.log(`‚ùå Erreur CORS: ${error.message}`, colors.red);
      this.results.failed++;
      this.results.errors.push(`CORS: ${error.message}`);
      return false;
    }
  }

  async testAPIConnectivity() {
    this.log('\nüß™ Test: Connectivit√© API depuis Frontend', colors.blue);
    this.results.total++;

    try {
      // Tester les endpoints principaux
      const endpoints = [
        { url: '/health', method: 'GET', expected: 200 },
        { url: '/auth/register', method: 'POST', expected: 400 }, // Sans donn√©es
        { url: '/fails/public', method: 'GET', expected: 401 }, // N√©cessite auth
        { url: '/badges/available', method: 'GET', expected: 401 } // N√©cessite auth
      ];

      for (const endpoint of endpoints) {
        const response = await fetch(`${BACKEND_URL}${endpoint.url}`, {
          method: endpoint.method,
          headers: {
            'Content-Type': 'application/json',
            'Origin': FRONTEND_URL
          }
        });

        if (response.status !== endpoint.expected) {
          throw new Error(`Endpoint ${endpoint.url}: attendu ${endpoint.expected}, re√ßu ${response.status}`);
        }
      }

      this.log(`‚úÖ Connectivit√© API fonctionnelle`, colors.green);
      this.results.passed++;
      return true;

    } catch (error) {
      this.log(`‚ùå Erreur connectivit√©: ${error.message}`, colors.red);
      this.results.failed++;
      this.results.errors.push(`Connectivit√© API: ${error.message}`);
      return false;
    }
  }

  // ==========================================
  // üîê TESTS D'AUTHENTIFICATION
  // ==========================================

  async testAuthenticationFlow() {
    this.log('\nüß™ Test: Flux d\'authentification Frontend', colors.blue);
    this.results.total++;

    try {
      // 1. Test inscription
      const registerData = {
        email: `test_frontend_${Date.now()}@example.com`,
        password: 'TestPassword123!',
        displayName: `TestUser${Date.now()}`,
        legalConsent: {
          documentsAccepted: ['terms', 'privacy'],
          consentDate: new Date().toISOString(),
          consentVersion: '1.0',
          marketingOptIn: false
        },
        ageVerification: {
          birthDate: '1990-01-01',
          isMinor: false,
          needsParentalConsent: false
        }
      };

      const registerResponse = await fetch(`${BACKEND_URL}/registration/register`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Origin': FRONTEND_URL
        },
        body: JSON.stringify(registerData)
      });

      if (!registerResponse.ok) {
        const error = await registerResponse.text();
        throw new Error(`Inscription √©chou√©e: ${error}`);
      }

      // 2. Test connexion
      const loginResponse = await fetch(`${BACKEND_URL}/auth/login`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Origin': FRONTEND_URL
        },
        body: JSON.stringify({
          email: registerData.email,
          password: registerData.password
        })
      });

      if (!loginResponse.ok) {
        throw new Error('Connexion √©chou√©e');
      }

      const loginData = await loginResponse.json();
      if (!loginData.token) {
        throw new Error('Token JWT manquant');
      }

      // 3. Test acc√®s prot√©g√©
      const profileResponse = await fetch(`${BACKEND_URL}/auth/profile`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${loginData.token}`,
          'Origin': FRONTEND_URL
        }
      });

      if (!profileResponse.ok) {
        throw new Error('Acc√®s au profil √©chou√©');
      }

      this.log(`‚úÖ Flux d'authentification complet fonctionnel`, colors.green);
      this.results.passed++;
      return { success: true, token: loginData.token };

    } catch (error) {
      this.log(`‚ùå Erreur authentification: ${error.message}`, colors.red);
      this.results.failed++;
      this.results.errors.push(`Authentification: ${error.message}`);
      return { success: false };
    }
  }

  // ==========================================
  // üì± TESTS DE FONCTIONNALIT√âS
  // ==========================================

  async testDataRetrieval(token) {
    this.log('\nüß™ Test: R√©cup√©ration des donn√©es', colors.blue);
    this.results.total++;

    if (!token) {
      this.log(`‚ö†Ô∏è  Skipp√©: Token manquant`, colors.yellow);
      return false;
    }

    try {
      const headers = {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
        'Origin': FRONTEND_URL
      };

      // Test r√©cup√©ration des fails
      const failsResponse = await fetch(`${BACKEND_URL}/fails/public?page=1&limit=10`, {
        headers
      });

      if (!failsResponse.ok) {
        throw new Error(`R√©cup√©ration fails √©chou√©e: ${failsResponse.status}`);
      }

      // Test r√©cup√©ration des badges
      const badgesResponse = await fetch(`${BACKEND_URL}/badges/available`, {
        headers
      });

      if (!badgesResponse.ok) {
        throw new Error(`R√©cup√©ration badges √©chou√©e: ${badgesResponse.status}`);
      }

      // V√©rifier la structure des donn√©es
      const failsData = await failsResponse.json();
      const badgesData = await badgesResponse.json();

      if (!Array.isArray(failsData.fails)) {
        throw new Error('Structure de donn√©es fails incorrecte');
      }

      if (!Array.isArray(badgesData)) {
        throw new Error('Structure de donn√©es badges incorrecte');
      }

      this.log(`‚úÖ R√©cup√©ration des donn√©es fonctionnelle`, colors.green);
      this.results.passed++;
      return true;

    } catch (error) {
      this.log(`‚ùå Erreur r√©cup√©ration: ${error.message}`, colors.red);
      this.results.failed++;
      this.results.errors.push(`R√©cup√©ration donn√©es: ${error.message}`);
      return false;
    }
  }

  // ==========================================
  // üìä RAPPORT FINAL
  // ==========================================

  generateReport() {
    this.log('\n' + '='.repeat(50), colors.bright);
    this.log('üìä RAPPORT DE TESTS FRONTEND', colors.bright);
    this.log('='.repeat(50), colors.bright);
    
    this.log(`\nüìà R√âSULTATS:`, colors.bright);
    this.log(`   Total des tests: ${this.results.total}`, colors.cyan);
    this.log(`   Tests r√©ussis:   ${this.results.passed} ‚úÖ`, colors.green);
    this.log(`   Tests √©chou√©s:   ${this.results.failed} ‚ùå`, colors.red);
    
    const successRate = this.results.total > 0 ? 
      ((this.results.passed / this.results.total) * 100).toFixed(1) : 0;
    
    this.log(`   Taux de r√©ussite: ${successRate}%`, 
      successRate >= 80 ? colors.green : successRate >= 60 ? colors.yellow : colors.red);

    if (this.results.errors.length > 0) {
      this.log(`\nüîç ERREURS D√âTECT√âES:`, colors.red);
      this.results.errors.forEach((error, index) => {
        this.log(`   ${index + 1}. ${error}`, colors.red);
      });
    }

    this.log(`\nüí° RECOMMANDATIONS:`, colors.yellow);
    
    if (this.results.failed === 0) {
      this.log(`   üéâ F√©licitations ! Tous les tests frontend passent.`, colors.green);
      this.log(`   üîó L'int√©gration Frontend-Backend est fonctionnelle.`, colors.green);
    } else {
      if (this.results.errors.some(e => e.includes('inaccessible'))) {
        this.log(`   1. D√©marrer le serveur frontend: cd frontend && npm start`, colors.yellow);
      }
      if (this.results.errors.some(e => e.includes('CORS'))) {
        this.log(`   2. V√©rifier la configuration CORS du backend`, colors.yellow);
      }
      if (this.results.errors.some(e => e.includes('Configuration'))) {
        this.log(`   3. V√©rifier les fichiers de configuration Angular`, colors.yellow);
      }
    }

    return {
      success: this.results.failed === 0,
      totalTests: this.results.total,
      passedTests: this.results.passed,
      failedTests: this.results.failed,
      successRate: parseFloat(successRate),
      errors: this.results.errors
    };
  }

  // ==========================================
  // üöÄ EX√âCUTION PRINCIPALE
  // ==========================================

  async runAllTests() {
    this.log('üöÄ D√âMARRAGE DES TESTS FRONTEND', colors.bright);
    this.log('=====================================', colors.bright);
    this.log(`Backend: ${BACKEND_URL}`, colors.cyan);
    this.log(`Frontend: ${FRONTEND_URL}`, colors.cyan);

    // V√©rifications pr√©liminaires
    const backendOk = await this.checkBackendStatus();
    if (!backendOk) {
      this.log('\n‚ùå Backend non disponible. Tests interrompus.', colors.red);
      return this.generateReport();
    }

    const frontendOk = await this.checkFrontendStatus();
    // Note: On continue m√™me si le frontend n'est pas d√©marr√© (tests de config)

    // Tests de configuration
    await this.testAngularEnvironment();
    await this.testAPIServices();

    // Tests d'int√©gration (si backend disponible)
    if (backendOk) {
      await this.testCORSConfiguration();
      await this.testAPIConnectivity();
      
      const authResult = await this.testAuthenticationFlow();
      if (authResult.success) {
        await this.testDataRetrieval(authResult.token);
      }
    }

    return this.generateReport();
  }
}

// ==========================================
// üèÉ‚Äç‚ôÇÔ∏è EX√âCUTION
// ==========================================

if (import.meta.url === `file://${process.argv[1]}`) {
  const testSuite = new FrontendTestSuite();
  
  testSuite.runAllTests()
    .then(result => {
      process.exit(result.success ? 0 : 1);
    })
    .catch(error => {
      console.error('‚ùå Erreur fatale:', error);
      process.exit(1);
    });
}

export default FrontendTestSuite;
