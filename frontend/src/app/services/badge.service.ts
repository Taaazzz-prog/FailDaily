import { Injectable } from '@angular/core';
import { Observable, from, BehaviorSubject } from 'rxjs';
import { map } from 'rxjs/operators';
import { Badge } from '../models/badge.model';
import { BadgeCategory } from '../models/enums';
import { MysqlService } from './mysql.service';
import { EventBusService, AppEvents } from './event-bus.service';

@Injectable({ providedIn: 'root' })
export class BadgeService {
  private userBadgesSubject = new BehaviorSubject<Badge[]>([]);
  public userBadges$ = this.userBadgesSubject.asObservable();

  // Syst√®me de debounce pour √©viter les v√©rifications trop fr√©quentes
  private lastBadgeCheck = 0;
  private readonly BADGE_CHECK_COOLDOWN = 2000; // 2 secondes entre les v√©rifications

  constructor(private mysqlService: MysqlService, private eventBus: EventBusService) {
    console.log('BadgeService: Constructor called - initializing badge service with MySQL backend');

    // Charger les badges utilisateur au d√©marrage
    console.log('BadgeService: Calling initializeBadges');
    this.initializeBadges();

    // √âcouter les √©v√©nements pour v√©rifier les badges automatiquement
    console.log('BadgeService: Setting up event listeners');
    this.setupEventListeners();
  }

  /**
   * Configure les √©couteurs d'√©v√©nements pour le d√©blocage automatique des badges
   */
  private setupEventListeners(): void {
    // √âcouter les √©v√©nements de cr√©ation de fail
    this.eventBus.on(AppEvents.FAIL_POSTED).subscribe(async (payload) => {
      console.log('√âv√©nement FAIL_POSTED re√ßu:', payload);
      try {
        const user = await this.mysqlService.getCurrentUser();
        if (user) {
          const newBadges = await this.checkAndUnlockBadgesWithCooldown(user.id, 'FAIL_POSTED');
          if (newBadges.length > 0) {
            this.eventBus.emit(AppEvents.BADGE_UNLOCKED, { badges: newBadges });
          }
        }
      } catch (error) {
        console.error('Erreur lors de la v√©rification des badges apr√®s cr√©ation de fail:', error);
      }
    });

    // √âcouter les √©v√©nements de r√©action
    this.eventBus.on(AppEvents.REACTION_GIVEN).subscribe(async (payload) => {
      console.log('√âv√©nement REACTION_GIVEN re√ßu:', payload);
      try {
        const user = await this.mysqlService.getCurrentUser();
        if (user) {
          const newBadges = await this.checkAndUnlockBadgesWithCooldown(user.id, 'REACTION_GIVEN');
          if (newBadges.length > 0) {
            this.eventBus.emit(AppEvents.BADGE_UNLOCKED, { badges: newBadges });
          }
        }
      } catch (error) {
        console.error('Erreur lors de la v√©rification des badges apr√®s r√©action:', error);
      }
    });
  }

  /**
   * V√©rifie les badges avec un syst√®me de cooldown pour √©viter les appels trop fr√©quents
   */
  private async checkAndUnlockBadgesWithCooldown(userId: string, eventType: string): Promise<Badge[]> {
    const now = Date.now();

    // Si la derni√®re v√©rification √©tait il y a moins de 2 secondes, ignorer
    if (now - this.lastBadgeCheck < this.BADGE_CHECK_COOLDOWN) {
      console.log(`‚è∞ Cooldown actif, v√©rification ignor√©e (${eventType})`);
      return [];
    }

    this.lastBadgeCheck = now;
    console.log(`üîç V√©rification des badges d√©clench√©e par: ${eventType}`);

    return await this.checkAndUnlockBadges(userId);
  }

  private async initializeBadges(): Promise<void> {
    try {
      // Attendre que l'utilisateur soit connect√©
      const user = await this.mysqlService.getCurrentUser();
      if (user) {
        await this.loadUserBadges(user.id);
      }
    } catch (error) {
      console.error('Erreur lors du chargement des badges:', error);
    }
  }

  private async loadUserBadges(userId: string): Promise<void> {
    try {
      const badgeIds = await this.mysqlService.getUserBadgesNew(userId);
      console.log('Badges r√©cup√©r√©s de la DB:', badgeIds);

      // R√©cup√©rer TOUS les badges disponibles (BDD + fallback)
      const allAvailableBadges = await this.getAllAvailableBadges();

      const userBadges = allAvailableBadges.filter(badge =>
        badgeIds.includes(badge.id)
      );
      console.log('Badges filtr√©s:', userBadges);

      this.userBadgesSubject.next(userBadges);
    } catch (error) {
      console.error('Erreur lors du chargement des badges utilisateur:', error);
    }
  }  /**
   * Force le rechargement des badges utilisateur depuis la base de donn√©es
   */
  async refreshUserBadges(): Promise<void> {
    const user = await this.mysqlService.getCurrentUser();
    if (user) {
      await this.loadUserBadges(user.id);
    }
  }

  /**
   * R√©cup√®re tous les badges disponibles UNIQUEMENT depuis la base de donn√©es
   */
  async getAllAvailableBadges(): Promise<Badge[]> {
    try {
      // R√©cup√©rer depuis la base de donn√©es
      const dbBadges = await this.mysqlService.getAllAvailableBadges();

      if (dbBadges && dbBadges.length > 0) {
        console.log(`‚ú® Badges charg√©s depuis la BDD: ${dbBadges.length} badges trouv√©s`);

        // Mapper les badges de la BDD vers le format Badge
        return dbBadges.map(dbBadge => ({
          id: String(dbBadge.id),
          name: dbBadge.name,
          description: dbBadge.description,
          icon: dbBadge.icon || 'trophy-outline',
          category: dbBadge.category || BadgeCategory.SPECIAL,
          rarity: 'common' as const, // Valeur par d√©faut
          // Ajouter les infos de requirement pour le nouveau syst√®me
          requirementType: dbBadge.requirements?.type,
          requirementValue: dbBadge.requirements?.value
        } as Badge));
      }

      // Plus de fallback - si pas de badges en BDD, retourner tableau vide
      console.log(`‚ùå Aucun badge trouv√© en base de donn√©es`);
      return [];
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des badges depuis la BDD:', error);
      return [];
    }
  }

  /**
   * R√©cup√®re une version filtr√©e des badges pour l'affichage par d√©faut
   * Seulement 2-3 badges par cat√©gorie, pas de legendaires
   */
  async getFilteredBadgesForDisplay(): Promise<Badge[]> {
    try {
      const allBadges = await this.getAllAvailableBadges();

      // Grouper les badges par cat√©gorie
      const badgesByCategory = allBadges.reduce((acc, badge) => {
        if (!acc[badge.category]) {
          acc[badge.category] = [];
        }
        acc[badge.category].push(badge);
        return acc;
      }, {} as { [key: string]: Badge[] });

      const filteredBadges: Badge[] = [];

      // Pour chaque cat√©gorie, prendre 2-3 badges (pas de legendaires)
      Object.keys(badgesByCategory).forEach(category => {
        const categoryBadges = badgesByCategory[category]
          .filter(badge => badge.rarity !== 'legendary') // Exclure les legendaires
          .sort((a, b) => {
            // Trier par raret√© (common -> rare -> epic)
            const rarityOrder = { 'common': 1, 'rare': 2, 'epic': 3 };
            return rarityOrder[a.rarity as keyof typeof rarityOrder] - rarityOrder[b.rarity as keyof typeof rarityOrder];
          });

        // Prendre les 3 premiers badges de chaque cat√©gorie
        filteredBadges.push(...categoryBadges.slice(0, 3));
      });

      console.log(`üéØ Badges filtr√©s pour affichage: ${filteredBadges.length}/${allBadges.length} badges`);
      return filteredBadges;
    } catch (error) {
      console.error('Erreur lors du filtrage des badges:', error);
      return []; // Plus de fallback hardcod√©
    }
  }

  /**
   * Version synchrone pour compatibilit√© - retourne un tableau vide car on n'utilise plus les badges hardcod√©s
   */
  getAllAvailableBadgesSync(): Badge[] {
    console.log('getAllAvailableBadgesSync est d√©pr√©ci√©e - utilisez getAllAvailableBadges() √† la place');
    return []; // Plus de badges hardcod√©s
  }

  /**
   * R√©cup√®re les badges de l'utilisateur
   */
  getUserBadges(): Observable<Badge[]> {
    return this.userBadges$;
  }

  /**
   * R√©cup√®re les badges d'un utilisateur sp√©cifique (pour admin)
   */
  async getUserBadgesForUser(userId: string): Promise<Badge[]> {
    try {
      console.log('üèÜ BadgeService: Getting badges for user:', userId);

      // R√©cup√©rer les IDs des badges de l'utilisateur
      const badgeIds = await this.mysqlService.getUserBadgesNew(userId);
      console.log('üèÜ BadgeService: User badge IDs:', badgeIds);

      // R√©cup√©rer tous les badges disponibles
      const allAvailableBadges = await this.getAllAvailableBadges();
      console.log('üèÜ BadgeService: Total available badges:', allAvailableBadges.length);

      // Filtrer les badges d√©bloqu√©s avec dates
      const userBadges = allAvailableBadges
        .filter(badge => badgeIds.includes(badge.id))
        .map(badge => ({ ...badge, unlockedDate: new Date() }));

      console.log('üèÜ BadgeService: User unlocked badges:', userBadges.length);
      return userBadges;
    } catch (error) {
      console.error('‚ùå Error getting user badges:', error);
      return [];
    }
  }

  /**
   * V√©rifie et d√©verrouille automatiquement les badges bas√©s sur les statistiques utilisateur
   */
  async checkAndUnlockBadges(userId: string): Promise<Badge[]> {
    console.log('üèÜ BadgeService: checkAndUnlockBadges called for user:', userId);

    try {
      console.log('üèÜ BadgeService: Getting user stats');
      const userStats = await this.getUserStats(userId);
      console.log('üèÜ BadgeService: User stats retrieved:', userStats);

      // CORRECTION: R√©cup√©rer les badges depuis la BDD, pas depuis le cache local
      console.log('üèÜ BadgeService: Getting current user badges from database');
      const currentBadgeIds = await this.mysqlService.getUserBadgesNew(userId);
      console.log('üèÜ BadgeService: Current user badges:', currentBadgeIds);

      console.log('üèÜ BadgeService: Getting all available badges');
      const allAvailableBadges = await this.getAllAvailableBadges();
      console.log('üèÜ BadgeService: Total available badges:', allAvailableBadges.length);

      const newBadges: Badge[] = [];

      console.log(`üèÜ BadgeService: V√©rification des badges pour ${allAvailableBadges.length} badges disponibles`);
      console.log(`üèÜ BadgeService: Badges actuels en BDD: [${currentBadgeIds.join(', ')}]`);
      console.log('üèÜ BadgeService: Stats utilisateur:', userStats);

      // V√©rifier chaque badge avec le nouveau syst√®me
      for (const badge of allAvailableBadges) {
        console.log('üèÜ BadgeService: Checking badge:', badge.id, 'already has?', currentBadgeIds.includes(badge.id));
        if (!currentBadgeIds.includes(badge.id)) {
          console.log('üèÜ BadgeService: Badge not unlocked yet, checking requirements for:', badge.id);
          if (this.checkBadgeRequirementsNew(badge, userStats)) {
            console.log('üèÜ BadgeService: Requirements met, unlocking badge:', badge.id);
            const unlocked = await this.unlockBadge(badge.id);
            if (unlocked) {
              newBadges.push(badge);
              console.log(`üèÜ Nouveau badge d√©bloqu√©: ${badge.name}`);
            }
          }
        }
      }

      console.log(`‚ú® ${newBadges.length} nouveaux badges d√©bloqu√©s`);
      return newBadges;
    } catch (error) {
      console.error('Erreur lors de la v√©rification des badges:', error);
      return [];
    }
  }

  /**
   * üöÄ M√âTHODE DEBUG - Pour tester les badges de bruno manuellement
   */
  async debugBadgeCheck(userId: string): Promise<any> {
    console.log('üöÄ DEBUG: V√©rification compl√®te des badges pour:', userId);

    try {
      // 1. Stats utilisateur
      const userStats = await this.getUserStats(userId);
      console.log('üìä Stats utilisateur:', userStats);

      // 2. Badges actuels en BDD
      const currentBadgeIds = await this.mysqlService.getUserBadgesNew(userId);
      console.log('‚úÖ Badges actuellement poss√©d√©s:', currentBadgeIds);

      // 3. Tous les badges disponibles
      const allBadges = await this.getAllAvailableBadges();
      console.log('üèÜ Total badges disponibles:', allBadges.length);

      // 4. Test de chaque badge
      const results = [];
      for (const badge of allBadges) {
        const alreadyHas = currentBadgeIds.includes(badge.id);
        const meetsReqs = this.checkBadgeRequirementsNew(badge, userStats);

        results.push({
          id: badge.id,
          name: badge.name,
          requirementType: badge.requirementType,
          requirementValue: badge.requirementValue,
          alreadyHas,
          meetsRequirements: meetsReqs,
          status: alreadyHas ? '‚úÖ Poss√©d√©' : (meetsReqs ? 'üéØ √âligible' : '‚ùå Pas encore')
        });

        console.log(`üèÜ ${badge.id}: ${results[results.length - 1].status}`);
      }

      return {
        userStats,
        currentBadgeIds,
        totalBadges: allBadges.length,
        badgeAnalysis: results
      };

    } catch (error) {
      console.error('‚ùå Erreur debug badges:', error);
      return null;
    }
  }

  /**
   * Nouvelle m√©thode qui utilise requirement_type et requirement_value de la BDD
   */
  private checkBadgeRequirementsNew(badge: Badge, userStats: any): boolean {
    if (!badge.requirementType || !badge.requirementValue) {
      console.log(`‚ö†Ô∏è Badge ${badge.id} n'a pas de requirements d√©finis en BDD - ignor√©`);
      return false; // Plus de fallback vers les badges hardcod√©s
    }

    const requiredValue = parseInt(badge.requirementValue, 10);
    console.log(`üîç V√©rification badge ${badge.id}: requirement ${badge.requirementType} >= ${requiredValue}`);

    switch (badge.requirementType) {
      case 'fail_count':
        return (userStats.totalFails || 0) >= requiredValue;

      case 'reaction_given':
      case 'like_given':
        return (userStats.totalReactions || 0) >= requiredValue;

      case 'comment_count':
        return (userStats.totalComments || 0) >= requiredValue;

      case 'courage_reactions':
        return (userStats.courageReactions || 0) >= requiredValue;

      case 'support_reactions':
        return (userStats.supportReactions || 0) >= requiredValue;

      case 'empathy_reactions':
        return (userStats.empathyReactions || 0) >= requiredValue;

      case 'laugh_reactions':
        return (userStats.laughReactions || 0) >= requiredValue;

      case 'streak_days':
        return (userStats.currentStreak || 0) >= requiredValue;

      case 'login_days':
        return (userStats.totalLoginDays || 0) >= requiredValue;

      case 'active_days':
        return (userStats.activeDays || 0) >= requiredValue;

      case 'categories_used':
        return (userStats.categoriesUsed || 0) >= requiredValue;

      case 'help_count':
        return (userStats.helpCount || 0) >= requiredValue;

      case 'helpful_comments':
        return (userStats.helpfulComments || 0) >= requiredValue;

      case 'unique_interactions':
        return (userStats.uniqueInteractions || 0) >= requiredValue;

      case 'positive_reactions':
        return (userStats.positiveReactions || 0) >= requiredValue;

      case 'total_laugh_reactions':
        return (userStats.totalLaughReactions || 0) >= requiredValue;

      case 'funny_fails':
        return (userStats.funnyFails || 0) >= requiredValue;

      case 'resilience_fails':
        return (userStats.resilienceFails || 0) >= requiredValue;

      case 'bounce_back_count':
        return (userStats.bounceBackCount || 0) >= requiredValue;

      case 'major_comebacks':
        return (userStats.majorComebacks || 0) >= requiredValue;

      case 'max_reactions_on_fail':
        return (userStats.maxReactionsOnFail || 0) >= requiredValue;

      case 'positive_days':
        return (userStats.positiveDays || 0) >= requiredValue;

      case 'challenges_overcome':
        return (userStats.challengesOvercome || 0) >= requiredValue;

      case 'inspired_users':
        return (userStats.inspiredUsers || 0) >= requiredValue;

      case 'comeback_count':
        return (userStats.comebackCount || 0) >= requiredValue;

      case 'midnight_fails':
        return (userStats.midnightFails || 0) >= requiredValue;

      case 'early_morning_fails':
        return (userStats.earlyMorningFails || 0) >= requiredValue;

      case 'weekend_fails':
        return (userStats.weekendFails || 0) >= requiredValue;

      case 'holiday_fails':
        return (userStats.holidayFails || 0) >= requiredValue;

      case 'new_year_fails':
        return (userStats.newYearFails || 0) >= requiredValue;

      case 'max_reactions_single':
        return (userStats.maxReactionsOnFail || 0) >= requiredValue;

      case 'badges_unlocked':
        return (userStats.badgesUnlocked || 0) >= requiredValue;

      case 'badges_percentage':
        const totalBadges = userStats.totalAvailableBadges || 100;
        const percentage = ((userStats.badgesUnlocked || 0) / totalBadges) * 100;
        return percentage >= requiredValue;

      default:
        console.log(`‚ö†Ô∏è Type de requirement inconnu: ${badge.requirementType}`);
        return false;
    }
  }

  private getUserStats(userId: string): Promise<any> {
    // V√©rifier que l'userId n'est pas undefined
    if (!userId || userId === 'undefined') {
      console.warn('‚ö†Ô∏è getUserStats appel√© avec un userId invalide:', userId);
      return Promise.resolve({
        totalFails: 0,
        totalReactionsGiven: 0,
        totalReactionsReceived: 0,
        couragePoints: 0,
        totalBadges: 0,
        streak: 0,
        reactionsByType: {},
        failsByCategory: {},
        mostPopularFails: []
      });
    }
    
    // R√©cup√©rer les statistiques utilisateur depuis MySQL
    return this.mysqlService.getUserStats(userId);
  }

  /**
   * D√©verrouille un badge sp√©cifique
   */
  private async unlockBadge(badgeId: string): Promise<boolean> {
    try {
      const user = await this.mysqlService.getCurrentUser();
      if (!user) return false;

      const success = await this.mysqlService.unlockBadge(user.id, badgeId);

      if (success) {
        // Recharger les badges utilisateur avec TOUS les badges disponibles
        await this.loadUserBadges(user.id);
        return true;
      }
      return false;
    } catch (error) {
      console.error('Erreur lors du d√©verrouillage du badge:', error);
      return false;
    }
  }

  /**
   * R√©cup√®re tous les badges de l'utilisateur actuel (obsol√®te - utiliser getUserBadges)
   */
  getBadges(): Observable<Badge[]> {
    return this.userBadges$;
  }

  /**
   * R√©cup√®re les statistiques d√©taill√©es pour les "Prochains d√©fis"
   * Affiche seulement 3-4 badges d√©j√† entam√©s (progress > 0) - les autres restent "secrets"
   */
  async getNextChallengesStats(): Promise<Array<{
    name: string;
    description: string;
    rarity: string;
    current: number;
    required: number;
    progress: number;
  }>> {
    try {
      const user = await this.mysqlService.getCurrentUser();
      if (!user || !user.id) {
        console.warn('‚ö†Ô∏è Utilisateur non connect√© ou ID manquant pour getNextChallengesStats');
        return [];
      }

      const userStats = await this.getUserStats(user.id);
      const userBadgeIds = await this.mysqlService.getUserBadgesNew(user.id);
      const allAvailableBadges = await this.getAllAvailableBadges();

      // Trouver les badges non d√©bloqu√©s et leurs statistiques
      const lockedBadges = allAvailableBadges.filter(badge =>
        !userBadgeIds.includes(badge.id)
      );
      
      console.log(`üîç DEBUG: ${userBadgeIds.length} badges d√©bloqu√©s, ${lockedBadges.length} badges non d√©bloqu√©s sur ${allAvailableBadges.length} total`);

      const challenges: Array<{
        name: string;
        description: string;
        rarity: string;
        current: number;
        required: number;
        progress: number;
      }> = [];

      for (const badge of lockedBadges) {
        const progress = await this.getBadgeProgressNew(badge, userStats);

        // Inclure les badges en cours ou les prochains logiques
        // Afficher si : progr√®s > 0 OU si c'est un badge proche du progr√®s actuel
        console.log(`üîç Badge "${badge.name}": current=${progress.current}, required=${progress.required}, progress=${progress.progress}`);
        
        // Logique d'affichage intelligente :
        // 1. Si du progr√®s existe (> 0) : toujours afficher
        // 2. Si pas de progr√®s mais badge proche (√©cart raisonnable) : afficher aussi
        const shouldDisplay = progress.current > 0 || 
                             (progress.current === 0 && progress.required <= userStats.failsCount + 15);
        
        if (shouldDisplay) {
          challenges.push({
            name: badge.name,
            description: badge.description,
            rarity: badge.rarity,
            current: Math.min(progress.current, progress.required),
            required: progress.required,
            progress: progress.progress
          });
        }
      }

      // Trier par progression d√©croissante (les plus proches d'√™tre d√©bloqu√©s en premier)
      // et limiter √† 4 badges maximum pour garder le focus
      return challenges
        .sort((a, b) => b.progress - a.progress)
        .slice(0, 4);
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des challenges:', error);
      return [];
    }
  }

  /**
   * Nouvelle m√©thode pour calculer le progress d'un badge avec le syst√®me requirement_type/requirement_value
   */
  private async getBadgeProgressNew(badge: Badge, userStats: any): Promise<{ current: number, required: number, progress: number }> {
    if (!badge.requirements || !badge.requirements.type || !badge.requirements.value) {
      console.warn('‚ö†Ô∏è Badge sans requirements:', badge.name);
      return { current: 0, required: 1, progress: 0 };
    }

    const required = typeof badge.requirements.value === 'string' ? 
                     parseInt(badge.requirements.value, 10) : 
                     badge.requirements.value;
    let current = 0;

    switch (badge.requirements.type) {
      case 'fail_count':
        current = userStats.totalFails || userStats.failsCount || 0;
        break;
      case 'reaction_given':
      case 'like_given':
        current = userStats.totalReactions || 0;
        break;
      case 'comment_count':
        current = userStats.totalComments || 0;
        break;
      case 'courage_reactions':
        current = userStats.courageReactions || 0;
        break;
      case 'support_reactions':
        current = userStats.supportReactions || 0;
        break;
      case 'empathy_reactions':
        current = userStats.empathyReactions || 0;
        break;
      case 'laugh_reactions':
        current = userStats.laughReactions || 0;
        break;
      case 'streak_days':
        current = userStats.currentStreak || 0;
        break;
      case 'login_days':
        current = userStats.totalLoginDays || 0;
        break;
      case 'active_days':
        current = userStats.activeDays || 0;
        break;
      case 'categories_used':
        current = userStats.categoriesUsed || 0;
        break;
      case 'max_reactions_single':
        current = userStats.maxReactionsOnFail || 0;
        break;
      case 'badges_unlocked':
        current = userStats.badgesUnlocked || 0;
        break;
      case 'badges_percentage':
        const totalBadges = userStats.totalAvailableBadges || 100;
        current = Math.round(((userStats.badgesUnlocked || 0) / totalBadges) * 100);
        break;
      default:
        current = 0;
    }

    const progress = required > 0 ? Math.min(current / required, 1) : 0;
    return { current: Math.min(current, required), required, progress };
  }
  async getBadgeProgress(badgeId: string): Promise<{ current: number, required: number, progress: number }> {
    const user = await this.mysqlService.getCurrentUser();
    if (!user) return { current: 0, required: 1, progress: 0 };

    const userStats = await this.getUserStats(user.id);
    let current = 0;
    let required = 1;

    switch (badgeId) {
      case 'first-fail':
        current = userStats.totalFails;
        required = 1;
        break;
      case 'first-reaction':
        current = userStats.totalReactions;
        required = 1;
        break;
      case 'fails-5':
        current = userStats.totalFails;
        required = 5;
        break;
      case 'fails-10':
        current = userStats.totalFails;
        required = 10;
        break;
      case 'fails-25':
        current = userStats.totalFails;
        required = 25;
        break;
      case 'reactions-10':
        current = userStats.totalReactions;
        required = 10;
        break;
      case 'reactions-50':
        current = userStats.totalReactions;
        required = 50;
        break;
      case 'all-categories':
        current = userStats.categoriesUsed;
        required = 5;
        break;
      case 'popular-fail':
        current = userStats.maxReactionsOnFail;
        required = 10;
        break;
      default:
        current = 0;
        required = 1;
    }

    const progress = Math.min(current / required, 1);
    return { current, required, progress };
  }

  /**
   * M√©thode utilitaire pour v√©rifier les badges apr√®s une action utilisateur
   * @deprecated Utiliser EventBus √† la place
   */
  async checkBadgesAfterAction(action: 'fail_posted' | 'reaction_given'): Promise<Badge[]> {
    console.log('üèÜ BadgeService: checkBadgesAfterAction called with action:', action);
    console.log('üèÜ BadgeService: checkBadgesAfterAction est d√©pr√©ci√©, utiliser EventBus √† la place');

    const user = await this.mysqlService.getCurrentUser();
    if (!user) {
      console.log('üèÜ BadgeService: No user found, returning empty badges array');
      return [];
    }

    console.log('üèÜ BadgeService: User found, checking and unlocking badges for user:', user.id);
    const result = await this.checkAndUnlockBadges(user.id);
    console.log('üèÜ BadgeService: Badge check completed, found', result.length, 'new badges');
    return result;
  }

  /**
   * Force la v√©rification manuelle des badges pour l'utilisateur actuel
   * Utile pour les tests et le d√©bogage
   */
  async forceCheckBadges(): Promise<Badge[]> {
    try {
      const user = await this.mysqlService.getCurrentUser();
      if (!user) {
        console.log('Aucun utilisateur connect√© pour la v√©rification des badges');
        return [];
      }

      console.log('üîç V√©rification forc√©e des badges pour:', user.email);
      const newBadges = await this.checkAndUnlockBadges(user.id);

      if (newBadges.length > 0) {
        console.log(`üèÜ ${newBadges.length} nouveaux badges d√©bloqu√©s:`, newBadges.map(b => b.name));
        // √âmettre l'√©v√©nement pour les notifications
        this.eventBus.emit(AppEvents.BADGE_UNLOCKED, { badges: newBadges });
        // Recharger les badges utilisateur
        await this.refreshUserBadges();
      } else {
        console.log('‚úÖ Aucun nouveau badge √† d√©bloquer');
      }

      return newBadges;
    } catch (error) {
      console.error('Erreur lors de la v√©rification forc√©e des badges:', error);
      return [];
    }
  }
}


