/**
 * üîÑ TEST 4.1 - TESTS D'INT√âGRATION COMPLETS
 * ==========================================
 * 
 * Sc√©narios complets d'utilisation de l'API
 */

const { API_CONFIG, TEST_UTILS, DEFAULT_HEADERS } = require('../0_test-config');

async function testCompleteIntegration() {
  TEST_UTILS.log('üîç', 'D√©but tests d\'int√©gration complets...');
  
  let success = true;
  const results = {
    userRegistration: false,
    userLogin: false,
    failCreation: false,
    failRetrieval: false,
    userStats: false,
    endToEndFlow: false,
    errors: []
  };

  const baseUrl = API_CONFIG.baseUrl;
  let userData = null;
  let authToken = null;
  let createdFailId = null;

  try {
    // Sc√©nario complet : Inscription ‚Üí Connexion ‚Üí Cr√©ation Fail ‚Üí R√©cup√©ration
    TEST_UTILS.log('üé¨', 'SC√âNARIO COMPLET D\'UTILISATION');
    
    // 1. Inscription utilisateur
    TEST_UTILS.log('1Ô∏è‚É£', 'Inscription utilisateur...');
    const testEmail = TEST_UTILS.generateTestEmail();
    const testPassword = 'password123';
    
    const registerData = {
      email: testEmail,
      password: testPassword,
      displayName: 'Utilisateur Int√©gration Test ' + Date.now()
    };

    const registerResponse = await fetch(`${baseUrl}/api/auth/register`, {
      method: 'POST',
      headers: DEFAULT_HEADERS,
      body: JSON.stringify(registerData)
    });

    if (registerResponse.status === 201) {
      const registerResult = await registerResponse.json();
      userData = registerResult.user;
      authToken = registerResult.token;
      results.userRegistration = true;
      TEST_UTILS.log('‚úÖ', `Utilisateur inscrit: ${userData.email}`);
    } else {
      const error = await registerResponse.json();
      results.errors.push(`Inscription √©chou√©e: ${error.error}`);
      success = false;
      return { success, results };
    }

    // 2. Connexion utilisateur (v√©rification du syst√®me d'auth)
    TEST_UTILS.log('2Ô∏è‚É£', 'Connexion utilisateur...');
    const loginData = {
      email: testEmail,
      password: testPassword
    };

    const loginResponse = await fetch(`${baseUrl}/api/auth/login`, {
      method: 'POST',
      headers: DEFAULT_HEADERS,
      body: JSON.stringify(loginData)
    });

    if (loginResponse.status === 200) {
      const loginResult = await loginResponse.json();
      authToken = loginResult.token; // Utiliser le nouveau token
      results.userLogin = true;
      TEST_UTILS.log('‚úÖ', 'Connexion r√©ussie');
    } else {
      results.errors.push('Connexion √©chou√©e');
      success = false;
    }

    // 3. Cr√©ation de plusieurs fails
    TEST_UTILS.log('3Ô∏è‚É£', 'Cr√©ation de fails...');
    const failsToCreate = [
      {
        title: 'Premier √©chec professionnel',
        description: 'J\'ai compl√®tement rat√© ma pr√©sentation importante',
        category: 'professionnel',
        is_anonyme: false
      },
      {
        title: '√âchec relationnel',
        description: 'Dispute avec un proche',
        category: 'relationnel',
        is_anonyme: true
      },
      {
        title: '√âchec financier',
        description: 'Mauvais investissement',
        category: 'financier',
        is_anonyme: false
      }
    ];

    let failsCreated = 0;
    for (const failData of failsToCreate) {
      const failResponse = await fetch(`${baseUrl}/api/fails`, {
        method: 'POST',
        headers: {
          ...DEFAULT_HEADERS,
          'Authorization': `Bearer ${authToken}`
        },
        body: JSON.stringify(failData)
      });

      if (failResponse.status === 201) {
        const failResult = await failResponse.json();
        if (failsCreated === 0) {
          createdFailId = failResult.fail.id;
        }
        failsCreated++;
        TEST_UTILS.log('‚úÖ', `Fail cr√©√©: ${failResult.fail.title}`);
      }
    }

    if (failsCreated === failsToCreate.length) {
      results.failCreation = true;
      TEST_UTILS.log('‚úÖ', `${failsCreated} fails cr√©√©s avec succ√®s`);
    } else {
      results.errors.push(`Seulement ${failsCreated}/${failsToCreate.length} fails cr√©√©s`);
    }

    // 4. R√©cup√©ration des fails
    TEST_UTILS.log('4Ô∏è‚É£', 'R√©cup√©ration des fails...');
    
    // Test d'acc√®s non autoris√© (sans token)
    const unauthenticatedResponse = await fetch(`${baseUrl}/api/fails`, {
      method: 'GET',
      headers: DEFAULT_HEADERS
    });

    if (unauthenticatedResponse.status === 401) {
      TEST_UTILS.log('‚úÖ', 'Protection authentification fonctionne - acc√®s refus√© sans token');
    } else {
      results.errors.push(`Acc√®s non autoris√© devrait retourner 401, re√ßu: ${unauthenticatedResponse.status}`);
    }

    // R√©cup√©ration avec auth (tous les fails visibles pour l'utilisateur)
    const allFailsResponse = await fetch(`${baseUrl}/api/fails`, {
      method: 'GET',
      headers: {
        ...DEFAULT_HEADERS,
        'Authorization': `Bearer ${authToken}`
      }
    });

    if (allFailsResponse.status === 200) {
      const allData = await allFailsResponse.json();
      
      // V√©rifier que l'utilisateur voit ses fails (publics et priv√©s)
      const userFails = allData.fails.filter(f => f.user_id === userData.id);
      
      if (userFails.length > 0) {
        results.failRetrieval = true;
        TEST_UTILS.log('‚úÖ', `R√©cup√©ration OK: ${userFails.length} fails visibles avec authentification`);
        
        // V√©rifier l'anonymat des autres auteurs
        const otherAuthorFails = allData.fails.filter(f => f.user_id !== userData.id);
        if (otherAuthorFails.length === 0 || !otherAuthorFails[0].author_name) {
          TEST_UTILS.log('‚úÖ', 'Anonymat pr√©serv√© pour les autres auteurs');
        }
      } else {
        TEST_UTILS.log('‚ÑπÔ∏è', 'Aucun fail trouv√© (normal si base vide)');
        results.failRetrieval = true;
      }
    } else {
      results.errors.push(`R√©cup√©ration des fails √©chou√©e: ${allFailsResponse.status}`);
    }

    // 5. R√©cup√©ration d'un fail sp√©cifique
    if (createdFailId) {
      TEST_UTILS.log('5Ô∏è‚É£', 'R√©cup√©ration fail sp√©cifique...');
      const specificFailResponse = await fetch(`${baseUrl}/api/fails/${createdFailId}`, {
        method: 'GET',
        headers: {
          ...DEFAULT_HEADERS,
          'Authorization': `Bearer ${authToken}`
        }
      });

      if (specificFailResponse.status === 200) {
        const specificData = await specificFailResponse.json();
        if (specificData.fail.id === createdFailId) {
          TEST_UTILS.log('‚úÖ', `Fail sp√©cifique r√©cup√©r√©: ${specificData.fail.title}`);
        }
      }
    }

    // 6. V√©rification token et profil
    TEST_UTILS.log('6Ô∏è‚É£', 'V√©rification token et session...');
    const verifyResponse = await fetch(`${baseUrl}/api/auth/verify`, {
      method: 'GET',
      headers: {
        ...DEFAULT_HEADERS,
        'Authorization': `Bearer ${authToken}`
      }
    });

    if (verifyResponse.status === 200) {
      const verifyData = await verifyResponse.json();
      if (verifyData.valid && verifyData.user.id === userData.id) {
        TEST_UTILS.log('‚úÖ', 'Token et session valides');
      }
    }

    // 7. Test de coh√©rence des donn√©es
    TEST_UTILS.log('7Ô∏è‚É£', 'V√©rification coh√©rence des donn√©es...');
    
    // V√©rifier que tous les fails cr√©√©s appartiennent bien √† l'utilisateur
    const userFailsResponse = await fetch(`${baseUrl}/api/fails?user=${userData.id}`, {
      method: 'GET',
      headers: {
        ...DEFAULT_HEADERS,
        'Authorization': `Bearer ${authToken}`
      }
    });

    if (userFailsResponse.status === 200) {
      const userFailsData = await userFailsResponse.json();
      const userOnlyFails = userFailsData.fails.every(fail => fail.user_id === userData.id);
      
      if (userOnlyFails) {
        TEST_UTILS.log('‚úÖ', 'Coh√©rence des donn√©es v√©rifi√©e');
      }
    }

    // 8. Test des limites et edge cases
    TEST_UTILS.log('8Ô∏è‚É£', 'Test des limites...');
    
    // Tentative de cr√©ation fail sans titre
    const invalidFailResponse = await fetch(`${baseUrl}/api/fails`, {
      method: 'POST',
      headers: {
        ...DEFAULT_HEADERS,
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify({
        description: 'Fail sans titre',
        category: 'autre'
      })
    });

    if (invalidFailResponse.status === 400) {
      TEST_UTILS.log('‚úÖ', 'Validation c√¥t√© serveur fonctionne');
    }

    // 9. D√©connexion
    TEST_UTILS.log('9Ô∏è‚É£', 'D√©connexion...');
    const logoutResponse = await fetch(`${baseUrl}/api/auth/logout`, {
      method: 'POST',
      headers: {
        ...DEFAULT_HEADERS,
        'Authorization': `Bearer ${authToken}`
      }
    });

    if (logoutResponse.status === 200) {
      TEST_UTILS.log('‚úÖ', 'D√©connexion r√©ussie');
      
      // V√©rifier que le token n'est plus valide
      const invalidTokenResponse = await fetch(`${baseUrl}/api/auth/verify`, {
        method: 'GET',
        headers: {
          ...DEFAULT_HEADERS,
          'Authorization': `Bearer ${authToken}`
        }
      });

      if (invalidTokenResponse.status === 403) {
        TEST_UTILS.log('‚úÖ', 'Token invalid√© apr√®s d√©connexion');
      }
    }

    // Marquer le flux end-to-end comme r√©ussi si on arrive ici
    results.endToEndFlow = true;
    TEST_UTILS.log('üéâ', 'Flux end-to-end complet r√©ussi!');

  } catch (error) {
    TEST_UTILS.log('‚ùå', `Erreur int√©gration: ${error.message}`);
    results.errors.push(`Erreur g√©n√©rale: ${error.message}`);
    success = false;
  }

  // R√©sultats finaux
  console.log('\nüìã R√âSULTATS TEST 4.1 - INT√âGRATION COMPL√àTE');
  console.log('=============================================');
  console.log(`Inscription: ${results.userRegistration ? '‚úÖ OK' : '‚ùå √âCHEC'}`);
  console.log(`Connexion: ${results.userLogin ? '‚úÖ OK' : '‚ùå √âCHEC'}`);
  console.log(`Cr√©ation fails: ${results.failCreation ? '‚úÖ OK' : '‚ùå √âCHEC'}`);
  console.log(`R√©cup√©ration fails: ${results.failRetrieval ? '‚úÖ OK' : '‚ùå √âCHEC'}`);
  console.log(`Flux end-to-end: ${results.endToEndFlow ? '‚úÖ OK' : '‚ùå √âCHEC'}`);
  
  if (results.errors.length > 0) {
    console.log('\n‚ùå ERREURS:');
    results.errors.forEach(error => console.log(`   - ${error}`));
  }
  
  const allTestsPassed = results.userRegistration && results.userLogin && 
                        results.failCreation && results.failRetrieval && 
                        results.endToEndFlow;
  
  console.log(`\nüéØ STATUT GLOBAL: ${allTestsPassed ? '‚úÖ SUCC√àS COMPLET' : '‚ùå √âCHEC'}\n`);
  
  return { success: allTestsPassed, results };
}

// Ex√©cution si appel√© directement
if (require.main === module) {
  testCompleteIntegration()
    .then(({ success }) => process.exit(success ? 0 : 1))
    .catch(error => {
      console.error('üí• Erreur fatale:', error);
      process.exit(1);
    });
}

module.exports = testCompleteIntegration;
